This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: docs/, src/assets/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    svelte5.mdc
public/
  vite.svg
src/
  lib/
    config/
      beaconConfig.ts
    stores/
      beaconStore.svelte.ts
      contractStore.svelte.ts
      tzktStorage.svelte.ts
      wallet.ts
    utils/
      contractLoader.ts
    beaconWallet.ts
    ContractAdmin.svelte
    ContractLoader.svelte
    ContractOps.svelte
    Counter.svelte
    CreateCompany.svelte
    NewContract.svelte
    Taq.svelte
    TestGlobal.svelte
    utils.ts
    WalletConnector.svelte
    WalletConnectorBeacon.svelte
  app.css
  App.svelte
  main.ts
  vite-env.d.ts
.gitignore
CLAUDE.md
components.json
index.html
package.json
postcss.config.js
README.md
svelte.config.js
tailwind.config.ts
tsconfig.json
tsconfig.node.json
vite.config.d.ts
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/svelte5.mdc">
---
description: 
globs: 
alwaysApply: true
---
I'm using svelte 5 instead of svelte 4 here is an overview of the changes.
# .cursorrunes for Svelte 5

## Overview of Changes

Svelte 5 introduces runes, a set of advanced primitives for controlling reactivity. The runes replace certain non-runes features and provide more explicit control over state and effects.

Snippets, along with render tags, help create reusable chunks of markup inside your components, reducing duplication and enhancing maintainability.

## Event Handlers in Svelte 5

In Svelte 5, event handlers are treated as standard HTML properties rather than Svelte-specific directives, simplifying their use and integrating them more closely with the rest of the properties in the component.

### Svelte 4 vs. Svelte 5:

**Before (Svelte 4):**
```html
<script>
  let count = 0;
  $: double = count * 2;
  $: {
    if (count > 10) alert('Too high!');
  }
</script>
<button on:click={() => count++}> {count} / {double}</button>
```

**After (Svelte 5):**
```html
<script>
  import { $state, $effect, $derived } from 'svelte';
  
  // Define state with runes
  let count = $state(0);
  
  // Option 1: Using $derived for computed values
  let double = $derived(count * 2);
  
  // Reactive effects using runes
  $effect(() => {
    if (count > 10) alert('Too high!');
  });
</script>

<!-- Standard HTML event attributes instead of Svelte directives -->
<button onclick={() => count++}>
  {count} / {double}
</button>

<!-- Alternatively, you can compute values inline -->
<!-- <button onclick={() => count++}>
  {count} / {count * 2}
</button> -->
```

## Key Differences:

1. **Reactivity is Explicit**: 
   - Svelte 5 uses `$state()` to explicitly mark reactive variables
   - `$derived()` replaces `$:` for computed values 
   - `$effect()` replaces `$: {}` blocks for side effects

2. **Event Handling is Standardized**:
   - Svelte 4: `on:click={handler}`
   - Svelte 5: `onclick={handler}`

3. **Import Runes**: 
   - All runes must be imported from 'svelte': `import { $state, $effect, $derived, $props, $slots } from 'svelte';`

4. **No More Event Modifiers**:
   - Svelte 4: `on:click|preventDefault={handler}`
   - Svelte 5: `onclick={e => { e.preventDefault(); handler(e); }}`

This creates clearer, more maintainable components compared to Svelte 4's previous syntax by making reactivity explicit and using standardized web platform features.
</file>

<file path=".gitignore">
node_modules
</file>

<file path="CLAUDE.md">
# CLAUDE.md - Governance Contract Frontend Guidelines

## Build Commands
- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run preview` - Preview production build
- `npm run check` - Run TypeScript type checking

## Code Style Guidelines
- **Formatting**: Use consistent indentation (2 spaces)
- **Imports**: Group imports: 1) external libs 2) Svelte/framework 3) local modules
- **State Management**: Use Svelte stores for shared state (`$state` for component state)
- **Types**: Define TypeScript interfaces for all data structures
- **Error Handling**: Always use try/catch blocks for async operations with proper error logging
- **Naming**: Use camelCase for variables/functions, PascalCase for components
- **Blockchain**: Reset provider before Tezos contract operations (use `resetProvider()`)
- **Components**: Keep contract-specific logic in dedicated components
- **Async**: Always handle promises properly with await/then and error catching
- **Console**: Use descriptive console logging for debugging operations

## Directory Structure
- `/src/lib/` - Reusable components and utilities
- `/src/lib/stores/` - Svelte stores for state management
- `/src/lib/config/` - Configuration files
- `/src/assets/` - Static assets and example files
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/lib/stores/contractStore.svelte.ts">
import { writable } from 'svelte/store';
import { TezosToolkit } from '@taquito/taquito';


interface ContractState {
    contractAddress: string | null;
}

export const contractState = writable<ContractState>({
    contractAddress: null
});

export const contractInstance = writable<any>(null);
</file>

<file path="src/lib/stores/tzktStorage.svelte.ts">
import { writable } from 'svelte/store';

export interface TzktTicket {
    data: string;
    amount: string;
    address: string;
}

export interface TzktStorageData {
    max_shares: string | null;
    owners_map: Record<string, string> | null;
    admin_address: string | null;
    issued_shares: string | null;
    share_balances: Record<string, TzktTicket> | null;
    registry_number: string | null;
    allocated_shares: string | null;
    all_shares_issued: boolean;
    issued_unclaimed_shares2: Record<string, TzktTicket> | null;
}

export const tzktStorageData = $state<TzktStorageData>({
    max_shares: null,
    owners_map: null,
    admin_address: null,
    issued_shares: null,
    share_balances: null,
    registry_number: null,
    allocated_shares: null,
    all_shares_issued: false,
    issued_unclaimed_shares2: null
});
</file>

<file path="src/lib/stores/wallet.ts">
import { TezosToolkit } from '@taquito/taquito';
import { TempleWallet } from '@temple-wallet/dapp';


export interface WalletData {
    wallet: TempleWallet | null;
    Tezos: TezosToolkit | null;
    userAddress: string | null;
    wbalance: string | null;
    walletDataAvailable: boolean;
}


export const walletState = $state<WalletData>({
    wallet: null,
    Tezos: null,
    userAddress: null,
    wbalance: null,
    walletDataAvailable: false
});
</file>

<file path="src/lib/beaconWallet.ts">
import { BeaconEvent, DAppClient, NetworkType } from "@airgap/beacon-sdk";

class BeaconWalletManager {
    private dAppClient: DAppClient;

    constructor() {
        this.dAppClient = new DAppClient({
            name: "TokenShareBeacon",
            preferredNetwork: NetworkType.GHOSTNET
        });

        // Set up default event listeners
        this.setupEventListeners();
    }

    private setupEventListeners() {
        this.dAppClient.subscribeToEvent(BeaconEvent.ACTIVE_ACCOUNT_SET, (account) => {
            console.log(`${BeaconEvent.ACTIVE_ACCOUNT_SET} triggered: `, account);
        });
    }

    async checkActiveAccount() {
        try {
            const activeAccount = await this.dAppClient.getActiveAccount();
            if (activeAccount) {
                console.log("Already connected:", activeAccount.address);
                return activeAccount;
            }
            return null;
        } catch (error) {
            console.error("Error checking active account:", error);
            return null;
        }
    }

    async requestPermissions() {
        try {
            const permissions = await this.dAppClient.requestPermissions({
                network: {
                    type: NetworkType.GHOSTNET,
                    rpcUrl: "https://ghostnet.smartpy.io"
                }
            });
            console.log("Got permissions:", permissions.address);
            return permissions;
        } catch (error) {
            console.error("Error requesting permissions:", error);
            throw error;
        }
    }

    async disconnect() {
        try {
            await this.dAppClient.disconnect();
            console.log("Disconnected");
        } catch (error) {
            console.error("Error disconnecting:", error);
            throw error;
        }
    }

    async clearActiveAccount() {
        try {
            await this.dAppClient.clearActiveAccount();
            const account = await this.dAppClient.getActiveAccount();
            console.log("Active Account after clear:", account);
            return account;
        } catch (error) {
            console.error("Error clearing active account:", error);
            throw error;
        }
    }
}

// Create and export a single instance
export const beaconWallet = new BeaconWalletManager();
</file>

<file path="src/lib/Counter.svelte">
<script lang="ts">
  let count: number = $state(0)
  const increment = () => {
    count += 1
  }
</script>

<button onclick={increment}>
  count is {count}
</button>
</file>

<file path="src/lib/CreateCompany.svelte">
<script lang="ts">
    import { Tezos, resetProvider, wallet } from './config/beaconConfig';
    import { beaconState } from './stores/beaconStore.svelte';
    import { contractInstance, contractState } from './stores/contractStore.svelte';

    let adminAddress: string = "";
    let maxShares: string = "";
    let registryNumber: string = "";

    // States for handling the transaction
    let isLoading = false;
    let txHash = "";
    let errorMsg = "";

    // The target contract address that holds the create_company entrypoint
    const governanceContractAddress: string = "KT1RceKkBayRFiFHGjTKumVR6weePNfWbZ3s";

    async function handleCreateCompany(event: Event) {
        event.preventDefault();
        isLoading = true;
        errorMsg = "";
        txHash = "";
        try {
            // Ensure all fields are provided
            if (!adminAddress || !maxShares || !registryNumber) {
                throw new Error("Please fill in all fields");
            }
            
            // Convert maxShares and registryNumber to nat (using parseInt)
            const maxSharesNat = parseInt(maxShares);
            const registryNumberNat = parseInt(registryNumber);
            
            if (isNaN(maxSharesNat) || isNaN(registryNumberNat)) {
                throw new Error("Max Shares and Registry Number must be valid numbers");
            }
            
            // Instead of using $contractInstance (which is for the current contract in view),
            // we instantiate a new contract instance for the governance contract.
            const governanceContract = await Tezos.wallet.at(governanceContractAddress);
            
            await resetProvider();
            // Call the create_company entrypoint
            // Using methodsObject to call the entrypoint by name with the proper parameters.
            const op = await governanceContract.methodsObject.default({
                companyID: registryNumberNat,
                shares: maxSharesNat,
                admin: adminAddress
            }).send();

            // Wait for confirmation
            await op.confirmation(2);
            txHash = op.opHash;
        } catch (error: any) {
            console.error("Error creating company:", error);
            errorMsg = error.message;
        } finally {
            isLoading = false;
        }
    }


  async function connectContract() {
        try {
            // First ensure provider is properly configured
            await resetProvider();
            
            console.log("Wallet ready for contract:", wallet?.getPKH());
        
            // if (!$contractState.contractAddress) {
            //     throw new Error("Contract address not set");
            // }
            // if (!beaconState.isConnected) {
            //     throw new Error("Wallet not connected");
            // }

            // Get the contract instance
            const contract = await Tezos.wallet.at(governanceContractAddress);
            console.log("Contract connected successfully", contract);
            contractInstance.set(contract);

            
        } catch (error) {
            console.error("Failed to load contract:", error);
            throw error;
        }
    }

</script>
<div class="container mx-auto p-4">
    
    <form onsubmit={handleCreateCompany} class="space-y-4 p-4 border rounded">
      <h2 class="text-2xl font-bold">Create a Company</h2>
    
      <div>
        <!-- svelte-ignore a11y_label_has_associated_control -->
        <label class="block text-sm font-medium text-gray-700">Company Admin Address</label>
        <input
          type="text"
          bind:value={adminAddress}
          placeholder="Admin Address"
          class="mt-1 block w-full p-2 border rounded"
          required
        />
      </div>
    
      <div>
        <!-- svelte-ignore a11y_label_has_associated_control -->
        <label class="block text-sm font-medium text-gray-700">Max Shares</label>
        <input
          type="number"
          bind:value={maxShares}
          placeholder="Maximum Shares"
          class="mt-1 block w-full p-2 border rounded"
          required
        />
      </div>
    
      <div>
        <!-- svelte-ignore a11y_label_has_associated_control -->
        <label class="block text-sm font-medium text-gray-700">Registry Number</label>
        <input
          type="number"
          bind:value={registryNumber}
          placeholder="Registry Number"
          class="mt-1 block w-full p-2 border rounded"
          required
        />
      </div>
    
      <button type="submit" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600" disabled={isLoading}>
        {#if isLoading}
          Sending...
        {:else}
          Create a Company
        {/if}
      </button>
    
      {#if txHash}
        <p class="text-green-600">Transaction sent! Hash: {txHash}</p>
      {/if}
    
      {#if errorMsg}
        <p class="text-red-600">{errorMsg}</p>
      {/if}
    </form>
</div>

<style>
  form {
    max-width: 500px;
    margin: 0 auto;
  }
</style>
</file>

<file path="src/lib/TestGlobal.svelte">
<div class="flex flex-col gap-4 p-6">
  <h2 class="text-2xl font-bold text-primary">Global Styles Test</h2>
  <div class="grid grid-cols-2 gap-4">
    <div class="bg-primary text-primary-foreground p-4 rounded-lg shadow-lg">
      Primary Style Box
    </div>
    <div class="bg-accent border-2 border-accent-foreground p-4 rounded-lg">
      Accent with Border
    </div>
    <div class="bg-destructive text-destructive-foreground p-4 rounded-lg font-bold">
      Destructive Style
    </div>
    <div class="bg-muted ring-2 ring-secondary text-secondary-foreground p-4 rounded-lg">
      Muted with Ring
    </div>
  </div>
</div>
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { cubicOut } from "svelte/easing";
import type { TransitionConfig } from "svelte/transition";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

type FlyAndScaleParams = {
	y?: number;
	x?: number;
	start?: number;
	duration?: number;
};

export const flyAndScale = (
	node: Element,
	params: FlyAndScaleParams = { y: -8, x: 0, start: 0.95, duration: 150 }
): TransitionConfig => {
	const style = getComputedStyle(node);
	const transform = style.transform === "none" ? "" : style.transform;

	const scaleConversion = (
		valueA: number,
		scaleA: [number, number],
		scaleB: [number, number]
	) => {
		const [minA, maxA] = scaleA;
		const [minB, maxB] = scaleB;

		const percentage = (valueA - minA) / (maxA - minA);
		const valueB = percentage * (maxB - minB) + minB;

		return valueB;
	};

	const styleToString = (
		style: Record<string, number | string | undefined>
	): string => {
		return Object.keys(style).reduce((str, key) => {
			if (style[key] === undefined) return str;
			return str + `${key}:${style[key]};`;
		}, "");
	};

	return {
		duration: params.duration ?? 200,
		delay: 0,
		css: (t) => {
			const y = scaleConversion(t, [0, 1], [params.y ?? 5, 0]);
			const x = scaleConversion(t, [0, 1], [params.x ?? 0, 0]);
			const scale = scaleConversion(t, [0, 1], [params.start ?? 0.95, 1]);

			return styleToString({
				transform: `${transform} translate3d(${x}px, ${y}px, 0) scale(${scale})`,
				opacity: t
			});
		},
		easing: cubicOut
	};
};
</file>

<file path="src/lib/WalletConnector.svelte">
<script lang="ts">
    import { onMount } from 'svelte';
    import { TezosToolkit } from '@taquito/taquito';
    import { TempleWallet } from '@temple-wallet/dapp';

    export const tezSym: string ='ꜩ';

    interface WalletData {
        wallet: TempleWallet | null;
        Tezos: TezosToolkit | null;
        userAddress: string | null;
        wbalance: string | null;
        walletDataAvailable: boolean;
    }

    export const walletState = $state<WalletData>({
        wallet: null,
        Tezos: null,
        userAddress: null,
        wbalance: null,
        walletDataAvailable: false
    });
    
    let Tezos: TezosToolkit = new TezosToolkit('https://ghostnet.smartpy.io');
    const wallet = new TempleWallet('TokenShare');

    onMount(async () => {
      try {
        const available = await TempleWallet.isAvailable();
        if (!available) throw new Error('Temple Wallet not installed');
        
        await wallet.connect('ghostnet');
        let userAddress = await wallet.getPKH();
        let balance = await getWalletBalance(userAddress);
      
        
        walletState.wallet = wallet;
        walletState.Tezos = wallet.toTezos();
        walletState.userAddress = userAddress;
        walletState.wbalance = balance.toFixed(2);;
        walletState.walletDataAvailable = true;

      } catch (err) {
        console.error(err);
        walletState.walletDataAvailable = false;
      }
    });

    async function getWalletBalance(address: string): Promise<number> {
        try {
            const balance = await Tezos.tz.getBalance(address);
            return balance.toNumber() / 1000000;
        } catch (error) {
            console.error("Failed to fetch balance:", error);
            return 0;
        }
    }


</script>

<div>
     <!-- Wallet Info -->
     <div class="mb-8 p-4 bg-gray-100 rounded-lg">
        <h2 class="text-2xl font-bold mb-4">Wallet Information</h2>
        {#if walletState.walletDataAvailable}
            <div class="grid grid-cols-5 gap-4">
                <div class="col-span-4">
                    <span class="font-semibold">Address:</span> 
                    <span class="font-mono">{walletState.userAddress}</span>
                </div>
                <div class="flex justify-end">
                    <span class="font-semibold">Balance:</span> 
                    <span>{walletState.wbalance} {tezSym}</span>
                </div>
            </div>
        {:else}
            <p>Loading wallet data...</p>
        {/if}
    </div>
</div>
</file>

<file path="src/app.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 210 40% 98%;
 
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="svelte" />
/// <reference types="vite/client" />
</file>

<file path="components.json">
{
	"$schema": "https://shadcn-svelte.com/schema.json",
	"style": "default",
	"tailwind": {
		"config": "tailwind.config.ts",
		"css": "src/app.{p,post}css",
		"baseColor": "slate"
	},
	"aliases": {
		"components": "$lib/components",
		"utils": "$lib/utils"
	},
	"typescript": true
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
};
</file>

<file path="README.md">
# Svelte + TS + Vite

This template should help get you started developing with Svelte and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).

## Need an official Svelte framework?

Check out [SvelteKit](https://github.com/sveltejs/kit#readme), which is also powered by Vite. Deploy anywhere with its serverless-first approach and adapt to various platforms, with out of the box support for TypeScript, SCSS, and Less, and easily-added support for mdsvex, GraphQL, PostCSS, Tailwind CSS, and more.

## Technical considerations

**Why use this over SvelteKit?**

- It brings its own routing solution which might not be preferable for some users.
- It is first and foremost a framework that just happens to use Vite under the hood, not a Vite app.

This template contains as little as possible to get started with Vite + TypeScript + Svelte, while taking into account the developer experience with regards to HMR and intellisense. It demonstrates capabilities on par with the other `create-vite` templates and is a good starting point for beginners dipping their toes into a Vite + Svelte project.

Should you later need the extended capabilities and extensibility provided by SvelteKit, the template has been structured similarly to SvelteKit so that it is easy to migrate.

**Why `global.d.ts` instead of `compilerOptions.types` inside `jsconfig.json` or `tsconfig.json`?**

Setting `compilerOptions.types` shuts out all other types not explicitly listed in the configuration. Using triple-slash references keeps the default TypeScript setting of accepting type information from the entire workspace, while also adding `svelte` and `vite/client` type information.

**Why include `.vscode/extensions.json`?**

Other templates indirectly recommend extensions via the README, but this file allows VS Code to prompt the user to install the recommended extension upon opening the project.

**Why enable `allowJs` in the TS template?**

While `allowJs: false` would indeed prevent the use of `.js` files in the project, it does not prevent the use of JavaScript syntax in `.svelte` files. In addition, it would force `checkJs: false`, bringing the worst of both worlds: not being able to guarantee the entire codebase is TypeScript, and also having worse typechecking for the existing JavaScript. In addition, there are valid use cases in which a mixed codebase may be relevant.

**Why is HMR not preserving my local component state?**

HMR state preservation comes with a number of gotchas! It has been disabled by default in both `svelte-hmr` and `@sveltejs/vite-plugin-svelte` due to its often surprising behavior. You can read the details [here](https://github.com/rixo/svelte-hmr#svelte-hmr).

If you have state that's important to retain within a component, consider creating an external store which would not be replaced by HMR.

```ts
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)
```
</file>

<file path="svelte.config.js">
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}
</file>

<file path="tailwind.config.ts">
import { fontFamily } from "tailwindcss/defaultTheme";
import type { Config } from "tailwindcss";

const config: Config = {
	darkMode: ["class"],
	content: ["./src/**/*.{html,js,svelte,ts}"],
	safelist: ["dark"],
	theme: {
		container: {
			center: true,
			padding: "2rem",
			screens: {
				"2xl": "1400px"
			}
		},
		extend: {
			colors: {
				border: "hsl(var(--border) / <alpha-value>)",
				input: "hsl(var(--input) / <alpha-value>)",
				ring: "hsl(var(--ring) / <alpha-value>)",
				background: "hsl(var(--background) / <alpha-value>)",
				foreground: "hsl(var(--foreground) / <alpha-value>)",
				primary: {
					DEFAULT: "hsl(var(--primary) / <alpha-value>)",
					foreground: "hsl(var(--primary-foreground) / <alpha-value>)"
				},
				secondary: {
					DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
					foreground: "hsl(var(--secondary-foreground) / <alpha-value>)"
				},
				destructive: {
					DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
					foreground: "hsl(var(--destructive-foreground) / <alpha-value>)"
				},
				muted: {
					DEFAULT: "hsl(var(--muted) / <alpha-value>)",
					foreground: "hsl(var(--muted-foreground) / <alpha-value>)"
				},
				accent: {
					DEFAULT: "hsl(var(--accent) / <alpha-value>)",
					foreground: "hsl(var(--accent-foreground) / <alpha-value>)"
				},
				popover: {
					DEFAULT: "hsl(var(--popover) / <alpha-value>)",
					foreground: "hsl(var(--popover-foreground) / <alpha-value>)"
				},
				card: {
					DEFAULT: "hsl(var(--card) / <alpha-value>)",
					foreground: "hsl(var(--card-foreground) / <alpha-value>)"
				}
			},
			borderRadius: {
				lg: "var(--radius)",
				md: "calc(var(--radius) - 2px)",
				sm: "calc(var(--radius) - 4px)"
			},
			fontFamily: {
				sans: [...fontFamily.sans]
			}
		}
	},
};

export default config;
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "emitDeclarationOnly": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.d.ts">
declare const _default: import("vite").UserConfig;
export default _default;
</file>

<file path="src/lib/utils/contractLoader.ts">
import { contractState } from '../stores/contractStore.svelte';
import { tzktStorageData } from '../stores/tzktStorage.svelte';
import { get } from 'svelte/store';

interface TzktTicket {
    data: string;
    amount: string;
    address: string;
}

interface TzktStorageData {
    owners_map: Record<string, string>;
    issued_unclaimed_shares2: Record<string, TzktTicket>;
    share_balances: Record<string, TzktTicket>;
    active_share_ledger: Record<string, string>;
    max_shares: string;
    admin_address: string;
    issued_shares: string;
    allocated_shares: string;
    all_shares_issued: boolean;
    registry_number?: string;
}

// Updated ContractEntries includes active ledger entries
interface ContractEntries {
    ownersMapEntries: [string, string][];
    unclaimedSharesEntries: [string, TzktTicket][];
    shareBalancesEntries: [string, TzktTicket][];
    activeLedgerEntries: [string, string][];
}

export async function loadContractTzkt(): Promise<ContractEntries> {
    try {
        const response = await fetch(`https://api.ghostnet.tzkt.io/v1/contracts/${get(contractState).contractAddress}/storage`);
        const data = await response.json() as TzktStorageData;
        
        // Update the global storage with the new data
        Object.assign(tzktStorageData, data);

        const entries: ContractEntries = {
            ownersMapEntries: Object.entries(data.owners_map ?? {}),
            unclaimedSharesEntries: Object.entries(data.issued_unclaimed_shares2 ?? {}),
            shareBalancesEntries: Object.entries(data.share_balances ?? {}),
            activeLedgerEntries: Object.entries(data.active_share_ledger ?? {})
        };

        console.log('TzKT Storage Data:', {
            max_shares: data.max_shares,
            admin_address: data.admin_address,
            issued_shares: data.issued_shares,
            allocated_shares: data.allocated_shares,
            all_shares_issued: data.all_shares_issued,
            owners_map: entries.ownersMapEntries,
            unclaimed: entries.unclaimedSharesEntries,
            balances: entries.shareBalancesEntries,
            activeLedger: entries.activeLedgerEntries
        });

        return entries;
    } catch (error) {
        console.error("Failed to load contract from TzKT API:", error);
        throw error;
    }
}
</file>

<file path="src/lib/NewContract.svelte">
<script lang="ts">
    import { tzktStorageData } from './stores/tzktStorage.svelte';
    import { beaconState, walletStore } from './stores/beaconStore.svelte';
    import { get } from "svelte/store";
    import contractCode from '../assets/walletContract.json';
    import initialStorage from '../assets/walletStorage.json';
    import { Tezos, wallet } from "./config/beaconConfig";
    import { MichelsonMap } from '@taquito/michelson-encoder';

    
    const storage = {
        admin_address : "tz1PfKWpMH8bJ3p5WRetGTZZM7idGP7kKW9M",
        all_shares_issued: false,
        allocated_shares: 0,
        issued_shares: 0,
        issued_unclaimed_shares2: new MichelsonMap(),
        max_shares: null,
        owners_map: new MichelsonMap(),
        registry_number: null,
        share_balances: new MichelsonMap()
    };

    async function originateContract() {
        Tezos.setProvider({wallet});
        // Originate a new contract
        const operation = await Tezos.wallet.originate({
            code: contractCode,
            storage: storage,
        }).send()
        .then((originationOp) => {
            console.log(`Waiting for confirmation of origination...`);
            return originationOp.contract();
        })
        .then((contract) => {
            console.log(`Origination completed for ${contract.address}.`);
        })
        .catch((error) => console.log(`Error: ${JSON.stringify(error, null, 2)}`));
        
    }
  

    // Debug effect to help track state changes
    $effect(() => {
        console.log('State Debug:', {
            beaconAddress: beaconState.address,
            adminAddress: tzktStorageData.admin_address,
        });
    });
</script>

<div>
    <button onclick={originateContract}>Originate Contract</button>
</div>
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TokenShare</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
</file>

<file path="src/lib/ContractAdmin.svelte">
<script lang="ts">
    import { onMount } from "svelte";
   
    import { TezosToolkit } from '@taquito/taquito';
    import { TempleWallet } from '@temple-wallet/dapp';
    import { MichelsonMap } from '@taquito/taquito';

    import contractCode2Originate from '../assets/walletContract.json';

    interface TzktTicket {
        data: string;
        amount: string;
        address: string;
    }

    interface TzktStorageData {
        max_shares: string;
        owners_map: Record<string, string>;
        admin_address: string;
        issued_shares: string;
        share_balances: Record<string, TzktTicket>;
        registry_number: string;
        allocated_shares: string;
        all_shares_issued: boolean;
        issued_unclaimed_shares2: Record<string, TzktTicket>;
    }

    const tezSym: string ='ꜩ';

    // Props and state
    export let contractAddress: string = '';
    let userAddress: string;
    let wbalance: string;
    let walletDataAvailable: boolean = false;
    let contractInstance: any = null;
    let storageData: any = null;
    let tzktStorageData: TzktStorageData | null = null;

    let Tezos: TezosToolkit = new TezosToolkit('https://ghostnet.smartpy.io');
    

    let tzktOwnersMapEntries: [string, string][] = [];
    let tzktUnclaimedSharesEntries: [string, any][] = [];
    let tzktShareBalancesEntries: [string, any][] = [];

    let contractScript: any = null;
    let contractCode: any = null;
    let contractStorageStructure: any = null;


    onMount(async () => {
        try {
            
        } catch (err) {
            console.error(err);

        }
    });


    async function loadContract() {
        try {
            contractInstance = await Tezos.wallet.at(contractAddress);
            storageData = await contractInstance.storage();
            //console.log(storageData.issued_unclaimed_shares2);
            for (const [address, ticket] of storageData.share_balances.entries()) {
                console.log(`Address: ${address}, Shares owned: ${ticket.amount}`);
            }

            for (const [key, ticket] of storageData.issued_unclaimed_shares2.entries()) {
                console.log('Issued unclaimed shares')
                console.log(`Key: ${key},  Ticketer: ${ticket.ticketer}, Value: ${ticket.value}, Amount: ${ticket.amount}`)
            }

            contractCode = contractInstance.script.code;
            contractStorageStructure = contractInstance.script.storage;
            console.log('contractStorageStructure')
            console.log(contractStorageStructure)
        } catch (error) {
            console.error("Failed to load contract:", error);
        }
    }

    async function loadContractTzkt() {
        try {
            const response = await fetch(`https://api.ghostnet.tzkt.io/v1/contracts/${contractAddress}/storage`);
            tzktStorageData = await response.json();
            
            // Process owners map
            tzktOwnersMapEntries = Object.entries(tzktStorageData?.owners_map ?? {});

            // Process unclaimed shares
            tzktUnclaimedSharesEntries = Object.entries(tzktStorageData?.issued_unclaimed_shares2 ?? {});

            // Process share balances
            tzktShareBalancesEntries = Object.entries(tzktStorageData?.share_balances ?? {});

            console.log('TzKT Storage Data:', tzktStorageData);
            console.log('Processed Entries:', {
                owners: tzktOwnersMapEntries,
                unclaimed: tzktUnclaimedSharesEntries,
                balances: tzktShareBalancesEntries
            });
        } catch (error) {
            console.error("Failed to load contract from TzKT API:", error);
        }
    }

    function extractStorageDataIntoVariables() {
        storageData
    }

</script>

<div class="container mx-auto p-4">

    <!-- Contract Loading -->
    <div class="mb-8">
        <div class="flex gap-4">
            <input 
                class="flex-1 p-2 border rounded" 
                bind:value={contractAddress} 
                placeholder="Enter contract address" 
            />
            <button 
                class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                on:click={loadContract}
            >
                Load Contract (Taquito)
            </button>
            <button 
                class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                on:click={loadContractTzkt}
            >
                Load Contract (TzKT)
            </button>
        </div>
    </div>
    <div class="grid grid-cols-2 gap-4">
        <!-- Taquito Contract Storage Display -->
        <div>
            {#if contractInstance && storageData}
            <div class="mb-8 p-4 bg-gray-100 rounded-lg">
                <h2 class="text-2xl font-bold mb-4">Contract Storage (Taquito)</h2>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <span class="font-semibold">Registry Number:</span> 
                        <span>{storageData.registry_number?.Some || 'Not set'}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Max Shares:</span> 
                        <span>{storageData.max_shares?.Some || 'Not set'}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Issued Shares:</span> 
                        <span>{storageData.issued_shares}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Allocated Shares:</span> 
                        <span>{storageData.allocated_shares}</span>
                    </div>
                    <div>
                        <span class="font-semibold">All Shares Issued:</span> 
                        <span>{storageData.all_shares_issued ? 'Yes' : 'No'}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Contract admin:</span> 
                        <span>{storageData.admin_address}</span>
                    </div>
                </div>

                <!-- Share Owners (Entitled to Claim) -->
                <div class="mt-4">
                    <h3 class="text-xl font-semibold mb-2">Share Owners (Entitled to Claim)</h3>
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="text-left p-2 bg-gray-200">Address</th>
                                <th class="text-right p-2 bg-gray-200">Entitled Shares</th>
                            </tr>
                        </thead>
                        <tbody>
                            {#if storageData?.owners_map && storageData.owners_map.size > 0}
                                {#each storageData.owners_map.entries() as [address, shares]}
                                    <tr class="border-t">
                                        <td class="font-mono p-2">{address}</td>
                                        <td class="text-right p-2">{shares}</td>
                                    </tr>
                                {/each}
                            {:else}
                                <tr class="border-t">
                                    <td class="text-center p-2 text-gray-500" colspan="2">No share owners registered</td>
                                </tr>
                            {/if}
                        </tbody>
                    </table>
                </div>

                <!-- Issued Unclaimed Shares -->
                <div class="mt-4">
                    <h3 class="text-xl font-semibold mb-2">Issued Unclaimed Shares</h3>
                    {#if storageData?.issued_unclaimed_shares2}
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="text-left p-2 bg-gray-200">Registry Number</th>
                                <th class="text-center p-2 bg-gray-200">Issuer</th>
                                <th class="text-right p-2 bg-gray-200">Amount</th>
                            </tr>
                        </thead>
                        <tbody>
                            {#if storageData?.issued_unclaimed_shares2 && storageData.issued_unclaimed_shares2.size > 0}
                                {#each Array.from((storageData!.issued_unclaimed_shares2 as MichelsonMap<any, any>).entries()) as [_, ticket]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">{ticket.value}</td>
                                    <td class="text-center p-2">{ticket.ticketer}</td>
                                    <td class="text-right p-2">{ticket.amount}</td>
                                </tr>    
                                {/each}
                            {:else}
                            <tr class="border-t">
                                <td class="text-center p-2 text-gray-500" colspan="3">No unclaimed shares</td>
                            </tr>
                            {/if}
                        </tbody>
                    </table>
                    {/if}
                </div>

                <!-- Share Balances (Owned Company Shares) -->
                <div class="mt-4">
                    <h3 class="text-xl font-semibold mb-2">Owned Company Shares</h3>
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="text-left p-2 bg-gray-200">Address</th>
                                <th class="text-right p-2 bg-gray-200">Shares owned</th>
                            </tr>
                        </thead>
                        <tbody>
                            {#if storageData?.share_balances && storageData.share_balances.size > 0}
                                {#each storageData.share_balances.entries() as [address, shares]}
                                    <tr class="border-t">
                                        <td class="font-mono p-2">{address}</td>
                                        <td class="text-right p-2">{shares.amount}</td>
                                    </tr>
                                {/each}
                            {:else}
                                <tr class="border-t">
                                    <td class="text-center p-2 text-gray-500" colspan="2">No shares owned</td>
                                </tr>
                            {/if}
                        </tbody>
                    </table>
                </div>
            </div>
            {/if}
        </div>

        <!-- TzKT Contract Storage Display -->
        <div>
            {#if tzktStorageData}
            <div class="mb-8 p-4 bg-gray-100 rounded-lg">
                <h2 class="text-2xl font-bold mb-4">Contract Storage (TzKT API)</h2>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <span class="font-semibold">Registry Number:</span> 
                        <span>{tzktStorageData.registry_number || 'Not set'}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Max Shares:</span> 
                        <span>{tzktStorageData.max_shares || 'Not set'}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Issued Shares:</span> 
                        <span>{tzktStorageData.issued_shares}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Allocated Shares:</span> 
                        <span>{tzktStorageData.allocated_shares}</span>
                    </div>
                    <div>
                        <span class="font-semibold">All Shares Issued:</span> 
                        <span>{tzktStorageData.all_shares_issued ? 'Yes' : 'No'}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Contract admin:</span> 
                        <span>{tzktStorageData.admin_address}</span>
                    </div>
                </div>

                <!-- Share Owners (Entitled to Claim) -->
                <div class="mt-4">
                    <h3 class="text-xl font-semibold mb-2">Share Owners (Entitled to Claim)</h3>
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="text-left p-2 bg-gray-200">Address</th>
                                <th class="text-right p-2 bg-gray-200">Entitled Shares</th>
                            </tr>
                        </thead>
                        <tbody>
                            {#if tzktOwnersMapEntries.length > 0}
                                {#each tzktOwnersMapEntries as [address, shares]}
                                    <tr class="border-t">
                                        <td class="font-mono p-2">{address}</td>
                                        <td class="text-right p-2">{shares}</td>
                                    </tr>
                                {/each}
                            {:else}
                                <tr class="border-t">
                                    <td class="text-center p-2 text-gray-500" colspan="2">No share owners registered</td>
                                </tr>
                            {/if}
                        </tbody>
                    </table>
                </div>

                <!-- Issued Unclaimed Shares -->
                <div class="mt-4">
                    <h3 class="text-xl font-semibold mb-2">Issued Unclaimed Shares</h3>
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="text-left p-2 bg-gray-200">Registry Number</th>
                                <th class="text-center p-2 bg-gray-200">Issuer</th>
                                <th class="text-right p-2 bg-gray-200">Amount</th>
                            </tr>
                        </thead>
                        <tbody>
                            {#if tzktUnclaimedSharesEntries.length > 0}
                                {#each tzktUnclaimedSharesEntries as [_, ticket]}
                                    <tr class="border-t">
                                        <td class="font-mono p-2">{ticket.data}</td>
                                        <td class="text-center p-2">{ticket.address}</td>
                                        <td class="text-right p-2">{ticket.amount}</td>
                                    </tr>
                                {/each}
                            {:else}
                                <tr class="border-t">
                                    <td class="text-center p-2 text-gray-500" colspan="3">No unclaimed shares</td>
                                </tr>
                            {/if}
                        </tbody>
                    </table>
                </div>

                <!-- Share Balances (Owned Company Shares) -->
                <div class="mt-4">
                    <h3 class="text-xl font-semibold mb-2">Owned Company Shares</h3>
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="text-left p-2 bg-gray-200">Address</th>
                                <th class="text-right p-2 bg-gray-200">Shares owned</th>
                            </tr>
                        </thead>
                        <tbody>
                            {#if tzktShareBalancesEntries.length > 0}
                                {#each tzktShareBalancesEntries as [_, shares]}
                                    <tr class="border-t">
                                        <td class="font-mono p-2">{shares.address}</td>
                                        <td class="text-right p-2">{shares.amount}</td>
                                    </tr>
                                {/each}
                            {:else}
                                <tr class="border-t">
                                    <td class="text-center p-2 text-gray-500" colspan="2">No shares owned</td>
                                </tr>
                            {/if}
                        </tbody>
                    </table>
                </div>
            </div>
            {/if}
        </div>
    </div>
</div>
</file>

<file path="src/main.ts">
import { Buffer } from 'buffer'
window.Buffer = Buffer
globalThis.Buffer = Buffer

import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

// Correct Svelte 5 mounting syntax
mount(App, {
  target: document.getElementById('app')!
})

// If you need to export the app instance
export default App
</file>

<file path="tsconfig.json">
{
  "extends": "./node_modules/@tsconfig/svelte/tsconfig.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "$lib": ["./src/lib"],
      "$lib/*": ["./src/lib/*"]
    },
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "types": ["node", "@taquito/taquito"],
    "moduleResolution": "node"
  },
  "include": ["src/**/*.ts", "src/**/*.js", "src/**/*.svelte"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'
import path from "path";

// https://vite.dev/config/
export default defineConfig({
  plugins: [svelte()],
  css: {
    postcss: './postcss.config.js',
  },
  resolve: {
    alias: {
      $lib: path.resolve("./src/lib"),
      buffer: 'buffer/',
      stream: 'stream-browserify',
      util: 'util/',
      events: 'events',
    },
  },
  optimizeDeps: {
    include: ['buffer', 'events', 'util', 'stream-browserify']
  },
  define: {
    'process.env': {},
    global: {},
  }
})
</file>

<file path="package.json">
{
  "name": "governance-contract-front",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-check --tsconfig ./tsconfig.json && tsc -p tsconfig.node.json"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^5.0.0",
    "@tsconfig/svelte": "^5.0.4",
    "@types/node": "^22.10.2",
    "autoprefixer": "^10.4.20",
    "clsx": "^2.1.1",
    "events": "^3.3.0",
    "stream-browserify": "^3.0.0",
    "svelte": "^5.2.7",
    "svelte-check": "^4.1.0",
    "tailwind-merge": "^2.5.5",
    "tailwind-variants": "^0.3.0",
    "tailwindcss": "^3.4.9",
    "tslib": "^2.8.1",
    "typescript": "~5.6.2",
    "util": "^0.12.5",
    "vite": "^6.0.6"
  },
  "dependencies": {
    "@airgap/beacon-dapp": "^4.3.1",
    "@airgap/beacon-sdk": "^4.3.1",
    "@tailwindcss/container-queries": "^0.1.1",
    "@tailwindcss/forms": "^0.5.9",
    "@tailwindcss/typography": "^0.5.15",
    "@taquito/beacon-wallet": "^20.1.2",
    "@taquito/taquito": "^17.5.2",
    "@temple-wallet/dapp": "^8.0.0",
    "buffer": "^6.0.3"
  }
}
</file>

<file path="src/lib/config/beaconConfig.ts">
import { type AccountInfo, DAppClient, type DAppClientOptions, NetworkType } from '@airgap/beacon-sdk';
import { TezosToolkit } from '@taquito/taquito';
import { BeaconWallet } from '@taquito/beacon-wallet';
import { BeaconEvent } from "@airgap/beacon-sdk";
import { walletStore } from '$lib/stores/beaconStore.svelte';


const rpcUrl_teztnets = "https://rpc.ghostnet.teztnets.com";
const rpcUrl_smartpy = "https://ghostnet.smartpy.io";
const rpcUrl_tzkt = "https://rpc.tzkt.io/ghostnet";


let tezosToolkitInstance = new TezosToolkit(rpcUrl_teztnets);
let beaconWalletInstance = new BeaconWallet({ 
    name: "Tokenshare Beacon Wallet", 
    preferredNetwork: NetworkType.GHOSTNET 
});


// Export configured instances
export const Tezos = tezosToolkitInstance;
export const wallet = beaconWalletInstance;

// Update wallet store
walletStore.set(beaconWalletInstance);


// Configure Tezos toolkit with wallet
tezosToolkitInstance.setWalletProvider(wallet);

if (wallet) {
    wallet.client.subscribeToEvent(BeaconEvent.ACTIVE_ACCOUNT_SET, async (account) => {
        console.log(
            `${BeaconEvent.ACTIVE_ACCOUNT_SET} triggered: `,
            account,
            account?.address,
        );

        if (!account) {
            return;
        }

        // // Re-enable the wallet provider just in case
        // Tezos.setWalletProvider(wallet);
    });
}




// const options: DAppClientOptions = {
//     name: 'TokenshareBeaconDApp',
//     iconUrl: 'https://taquito.io/img/favicon.svg',
//     network: { type: NetworkType.GHOSTNET },
//     enableMetrics: true,
// };

// let beaconDAppClientInstance: DAppClient | null = null;


// export function getBeaconDAppClient(): DAppClient {
//     if (beaconDAppClientInstance === null) {
//         beaconDAppClientInstance = new DAppClient(options);
//         console.log("Creating a new DAppClient instance");
//     }
//     return beaconDAppClientInstance;
// }

// export function getTezosToolkit(): TezosToolkit {
//     if (tezosToolkitInstance === null) {
//         tezosToolkitInstance = new TezosToolkit(rpcUrl_teztnets);
//         console.log("Creating a new TezosToolkit instance");
//     }
//     return tezosToolkitInstance;
// }

// export function getBeaconWallet(): BeaconWallet {
//     if (beaconWalletInstance === null) {
//         beaconWalletInstance = new BeaconWallet({ 
//             name: "Tokenshare Beacon Wallet", 
//             preferredNetwork: NetworkType.GHOSTNET });
//         console.log("Creating a new BeaconWallet instance");
//         walletStore.set(beaconWalletInstance);
//     }
//     return beaconWalletInstance;
// }

// Helper functions
export async function getActiveAccount(): Promise<AccountInfo | undefined> {
    try {
        const activeAccount = await wallet.client.getActiveAccount();
        if (activeAccount) {
            console.log("Active account:", activeAccount.address);
            
            // Important: Ensure wallet provider is set
            Tezos.setWalletProvider(wallet);
            
            return activeAccount;
        }
        return undefined;
    } catch (error) {
        console.error("Error getting active account:", error);
        return undefined;
    }
}

export async function resetProvider() {
    // First disconnect existing provider if any
    Tezos.setProvider({ rpc: rpcUrl_teztnets });
    // Then set wallet provider again
    Tezos.setWalletProvider(wallet);
}
</file>

<file path="src/lib/stores/beaconStore.svelte.ts">
import { NetworkType } from '@airgap/beacon-sdk';
import { BeaconWallet } from '@taquito/beacon-wallet';
import { writable } from 'svelte/store';


export const walletStore = writable<BeaconWallet | null>(null);


interface BeaconState {
    address: string | null;
    wbalance: number | null;
    isConnected: boolean;
    network: NetworkType;
    error: string | null;
}

export const beaconState = $state<BeaconState>({
    address: null,
    wbalance: null,
    isConnected: false,
    network: NetworkType.GHOSTNET,
    error: null
});
</file>

<file path="src/lib/ContractLoader.svelte">
<script lang="ts">
    import { onMount } from "svelte";
    import { contractState } from './stores/contractStore.svelte';
    import { tzktStorageData } from './stores/tzktStorage.svelte';
    import ContractOps from "./ContractOps.svelte";
    import { loadContractTzkt } from './utils/contractLoader';
    import CreateCompany from "./CreateCompany.svelte";
    
    interface TzktTicket {
        data: string;
        amount: string;
        address: string;
    }

    let tzktOwnersMapEntries = $state<[string, string][]>([]);
    let tzktUnclaimedSharesEntries = $state<[string, TzktTicket][]>([]);
    let tzktShareBalancesEntries = $state<[string, TzktTicket][]>([]);
    let tzktActiveLedgerEntries = $state<[string, string][]>([]);

    /**
     * Test contracts
     * KT1SP3hazeQKE1Sk8MKaCED86GPGhyX2Jyu3
     * KT1SJjCTroZ3NgZJSqZp48EXWknGntFWVSKC
    */

    onMount(async () => {
        try {
            
        } catch (err) {
            console.error(err);

        }
    });

    async function handleLoadContract() {
        const entries = await loadContractTzkt();
        tzktOwnersMapEntries = entries.ownersMapEntries;
        tzktUnclaimedSharesEntries = entries.unclaimedSharesEntries;
        tzktShareBalancesEntries = entries.shareBalancesEntries;
        tzktActiveLedgerEntries = entries.activeLedgerEntries;
    }

</script>

<div class="container mx-auto p-4">
    <CreateCompany />
    
    <!-- Contract Loading -->
    <div class="mb-8">
        <div class="flex gap-4">
            <input 
                class="flex-1 p-2 border rounded" 
                bind:value={$contractState.contractAddress} 
                placeholder="Enter contract address" 
            />
            <button 
                class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                onclick={handleLoadContract}
            >
                Load Contract (TzKT 2)
            </button>
        </div>
    </div>

    <!-- TzKT Contract Storage Display -->
    {#if tzktStorageData.admin_address !== null}
        <div class="mb-8 p-4 bg-gray-100 rounded-lg">
            <h2 class="text-2xl font-bold mb-4">Contract Storage (TzKT API)</h2>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <span class="font-semibold">Registry Number:</span> 
                    <span>{tzktStorageData.registry_number || 'Not set'}</span>
                </div>
                <div>
                    <span class="font-semibold">Max Shares:</span> 
                    <span>{tzktStorageData.max_shares || 'Not set'}</span>
                </div>
                <div>
                    <span class="font-semibold">Contract admin:</span> 
                    <span>{tzktStorageData.admin_address}</span>
                </div>
                <div>
                    <span class="font-semibold">Issued Shares:</span> 
                    <span>{tzktStorageData.issued_shares}</span>
                </div>
                <div>
                    <span class="font-semibold">All Shares Issued:</span> 
                    <span>{tzktStorageData.all_shares_issued ? 'Yes' : 'No'}</span>
                </div>
                <div>
                    <span class="font-semibold">Allocated Shares:</span> 
                    <span>{tzktStorageData.allocated_shares}</span>
                </div>
            </div>

            <!-- Issued Unclaimed Shares -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Issued Unclaimed Shares</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Issuer</th>
                            <th class="text-right p-2 bg-gray-200">Amount</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if tzktUnclaimedSharesEntries.length > 0}
                            {#each tzktUnclaimedSharesEntries as [_, ticket]}
                                <tr class="border-t">
                                    <td class="text-left p-2">{ticket.address}</td>
                                    <td class="text-right p-2">{ticket.amount}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr class="border-t">
                                <td class="text-center p-2 text-gray-500" colspan="3">No unclaimed shares</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>
            
            <!-- Share Owners (Entitled to Claim) -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Share Owners (Entitled to Claim)</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Address</th>
                            <th class="text-right p-2 bg-gray-200">Entitled Shares</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if tzktOwnersMapEntries.length > 0}
                            {#each tzktOwnersMapEntries as [address, shares]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">
                                        {#if address.startsWith('KT1')}
                                            <button 
                                                class="text-blue-600 hover:text-blue-800 hover:underline text-left"
                                                onclick={() => {
                                                    $contractState.contractAddress = address;
                                                    handleLoadContract();
                                                }}
                                            >
                                                {address}
                                            </button>
                                        {:else}
                                            {address}
                                        {/if}
                                    </td>
                                    <td class="text-right p-2">{shares}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr class="border-t">
                                <td class="text-center p-2 text-gray-500" colspan="2">No share owners registered</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>

            <!-- Active Share Ledger -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Active Share Ledger</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Address</th>
                            <th class="text-right p-2 bg-gray-200">Owned Shares</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if tzktActiveLedgerEntries.length > 0}
                            {#each tzktActiveLedgerEntries as [address, claimedShares]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">
                                        {#if address.startsWith("KT1")}
                                            <button 
                                                class="text-blue-600 hover:text-blue-800 hover:underline text-left"
                                                onclick={() => {
                                                    $contractState.contractAddress = address;
                                                    handleLoadContract();
                                                }}
                                            >
                                                {address}
                                            </button>
                                        {:else}
                                            {address}
                                        {/if}
                                    </td>
                                    <td class="text-right p-2">{claimedShares}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr class="border-t">
                                <td class="text-center p-2 text-gray-500" colspan="2">No active share ledger entries</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>

            <!-- Share Balances (Owned Company Shares) -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Owned Company Shares</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Address</th>
                            <th class="text-right p-2 bg-gray-200">Shares owned</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if tzktShareBalancesEntries.length > 0}
                            {#each tzktShareBalancesEntries as [_, shares]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">
                                        <button 
                                            class="text-blue-600 hover:text-blue-800 hover:underline text-left"
                                            onclick={() => {
                                                $contractState.contractAddress = shares.address;
                                                handleLoadContract();
                                            }}
                                        >
                                            {shares.address}
                                        </button>
                                    </td>
                                    <td class="text-right p-2">{shares.amount}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr class="border-t">
                                <td class="text-center p-2 text-gray-500" colspan="2">No shares owned</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>


        </div>
    {/if}

    {#if $contractState.contractAddress !== null}
        <div>
            <h2 class="text-2xl font-bold mb-4">Contract Operations</h2>
            <ContractOps />
        </div>
    {/if}
</div>
</file>

<file path="src/App.svelte">
<script lang="ts">

  import TestGlobal from './lib/TestGlobal.svelte'

  import WalletConnectorBeacon from './lib/WalletConnectorBeacon.svelte'

  import ContractLoader from '$lib/ContractLoader.svelte';
  import NewContract from '$lib/NewContract.svelte';

</script>

<main class="min-h-screen bg-gray-400 p-4 flex flex-col">
  <div class="flex-grow-0">

    <h1 class="text-3xl font-bold text-blue-600">TokenShare</h1>



    <div class="mt-4">
      <WalletConnectorBeacon />
    </div>

    <div class="mt-4">
      <NewContract />
    </div>

    <div class="mt-4">
      <ContractLoader />
    </div>


     
  </div>
  
  <div class="mt-auto">
    <TestGlobal />
  </div>
</main>

<style>


</style>
</file>

<file path="src/lib/Taq.svelte">
<script lang="ts">
    import { onMount } from "svelte";
   
    import { TezosToolkit } from '@taquito/taquito';
    import { TempleWallet } from '@temple-wallet/dapp';

    let Tezos: TezosToolkit = new TezosToolkit('https://ghostnet.smartpy.io');



        // Props and state
    export let contractAddress: string = '';
    let userAddress: string;
    let wbalance: string;
    let walletDataAvailable: boolean = false;
    let contractInstance: any = null;
    let storageData: any = null;


    let ownersMapEntries: [string, number][] = [];
    let unclaimedSharesEntries: [string, any][] = [];
    let shareBalancesEntries: [string, any][] = [];
    
    /**
     
    const testWallets: Wallets = {
        'Kaspar': {'address': 'tz1QSUqRdw5fx5E24q2LGcPmiekyP38L3GpXf', 'balance': 0},
        'kspr': {'address': 'tz1RuTC6e6FxWLTPPjAG3tesiBwwkK1bBkqR', 'balance': 0}
    }
    tz1QSURdw5fx5E24q2LGcPmiekyP38L3GpXf
    tz1QSURdw5fx5E24q2LGcPmiekyP38L3GpXf
    tz1QSURdw5fx5E24q2LGcPmiekyP38L3GpXf
    tz1QSURdw5fx5E24q2LGcPmiekyP38L3GpXf
    */
    
   
    /** Testing working with ticket and imp addresses */
    /**
     * 
     const wallet_kspr: string = "tz1RuTC6e6FxWLTPPjAG3tesiBwwkK1bBkqR"
     
     let ticketToken = {
        ticketer: 'TICKETER_ADDRESS', // Contract address that issued the ticket
        value: {
            // Ticket value details (e.g., content), match the ticket schema
            content_type: { prim: 'string' },
            content: { string: 'Ticket' }
        },
        amount: 1 // Number of tickets to send
    };
    
    */
 
    /*
        let walletDataAvailable: boolean = false;
        let userAddress: string;
        let wbalance: string;

        let contractAddress: string = '';
        let contractInstance: any = null;
        let storageData: any = null;Contract data
    */


    // Form states
    let adminForms = {
        addShareOwner: { amount: '', ownerAddress: '' },
        changeMaxShares: { newMax: '' },
        issueShares: { amount: '' }
    };
    
    let userForms = {
        transferShares: { amount: '', destination: '', share: '' },
        claimShares: { address: '' }
    };

    onMount(async () => {
       
        try {
            
        } catch (err) {
            console.error(err);
            
        }
    });

    async function getWalletBalance(address: string): Promise<number> {
        try {
            const balance = await Tezos.tz.getBalance(address);
            return balance.toNumber() / 1000000;
        } catch (error) {
            console.error("Failed to fetch balance:", error);
            return 0;
        }
    }

    async function loadContract() {
        try {
            contractInstance = await Tezos.wallet.at(contractAddress);
            storageData = await contractInstance.storage();
            
            // Process owners map
            ownersMapEntries = [];
            storageData.owners_map.forEach((value: number, key: string) => {
                ownersMapEntries.push([key, value]);
            });

            // Process unclaimed shares
            unclaimedSharesEntries = [];
            storageData.issued_unclaimed_shares2.forEach((value: any, key: string) => {
                unclaimedSharesEntries.push([key, value]);
            });

            // Process share balances
            shareBalancesEntries = [];
            storageData.share_balances.forEach((value: any, key: string) => {
                shareBalancesEntries.push([key, value]);
            });

        } catch (error) {
            console.error("Failed to load contract:", error);
        }
    }

    // Admin Functions
    async function addShareOwner() {
        try {
            const operation = await contractInstance.methods.add_share_owner(
                adminForms.addShareOwner.amount,
                adminForms.addShareOwner.ownerAddress
            ).send();
            await operation.confirmation();
            await loadContract(); // Refresh data
        } catch (error) {
            console.error("Failed to add share owner:", error);
        }
    }

    async function changeMaxShares() {
        try {
            const operation = await contractInstance.methods.change_max_shares(
                adminForms.changeMaxShares.newMax
            ).send();
            await operation.confirmation();
            await loadContract();
        } catch (error) {
            console.error("Failed to change max shares:", error);
        }
    }

    async function issueShares() {
        try {
            const operation = await contractInstance.methods.issue_shares_unclaimed2(
                adminForms.issueShares.amount
            ).send();
            await operation.confirmation();
            await loadContract();
        } catch (error) {
            console.error("Failed to issue shares:", error);
        }
    }

    // User Functions
    async function transferShares() {
        try {
            const operation = await contractInstance.methods.transfer_shares(
                userForms.transferShares.amount,
                userForms.transferShares.destination,
                userForms.transferShares.share
            ).send();
            await operation.confirmation();
            await loadContract();
        } catch (error) {
            console.error("Failed to transfer shares:", error);
        }
    }

    async function claimShares() {
        try {
            const operation = await contractInstance.methods.claim_shares(
                userForms.claimShares.address
            ).send();
            await operation.confirmation();
            await loadContract();
        } catch (error) {
            console.error("Failed to claim shares:", error);
        }
    }

    //$: isAdmin = storageData?.admin_address === userAddress;
</script>

<div class="container mx-auto p-4">

    <!-- Contract Loading -->
    <div class="mb-8">
        <div class="flex gap-4">
            <input 
                class="flex-1 p-2 border rounded" 
                bind:value={contractAddress} 
                placeholder="Enter contract address" 
            />
            <button 
                class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                on:click={loadContract}
            >
                Load Contract
            </button>
        </div>
    </div>

    {#if contractInstance && storageData}
        <!-- Contract Storage Display -->
        <div class="mb-8 p-4 bg-gray-100 rounded-lg">
            <h2 class="text-2xl font-bold mb-4">Contract Storage</h2>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <span class="font-semibold">Registry Number:</span> 
                    <span>{storageData.registry_number?.Some || 'Not set'}</span>
                </div>
                <div>
                    <span class="font-semibold">Max Shares:</span> 
                    <span>{storageData.max_shares?.Some || 'Not set'}</span>
                </div>
                <div>
                    <span class="font-semibold">Issued Shares:</span> 
                    <span>{storageData.issued_shares}</span>
                </div>
                <div>
                    <span class="font-semibold">Allocated Shares:</span> 
                    <span>{storageData.allocated_shares}</span>
                </div>
                <div>
                    <span class="font-semibold">All Shares Issued:</span> 
                    <span>{storageData.all_shares_issued ? 'Yes' : 'No'}</span>
                </div>
            </div>

            <!-- Share Owners (Entitled to Claim) -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Share Owners (Entitled to Claim)</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Address</th>
                            <th class="text-right p-2 bg-gray-200">Entitled Shares</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if ownersMapEntries.length > 0}
                            {#each ownersMapEntries as [address, shares]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">{address}</td>
                                    <td class="text-right p-2">{shares}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr>
                                <td colspan="2" class="text-center p-2">No share owners found</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>

            <!-- Issued Unclaimed Shares -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Issued Unclaimed Shares</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Company Address</th>
                            <th class="text-right p-2 bg-gray-200">Registry Number</th>
                            <th class="text-right p-2 bg-gray-200">Amount</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if unclaimedSharesEntries.length > 0}
                            {#each unclaimedSharesEntries as [id, ticket]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">{ticket.ticketer}</td>
                                    <td class="text-right p-2">{ticket.value}</td>
                                    <td class="text-right p-2">{ticket.amount}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr>
                                <td colspan="3" class="text-center p-2">No unclaimed shares found</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>

            <!-- Share Balances (Owned Tickets) -->
            <div class="mt-4">
                <h3 class="text-xl font-semibold mb-2">Share Balances (Owned Company Shares)</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th class="text-left p-2 bg-gray-200">Company Address</th>
                            <th class="text-right p-2 bg-gray-200">Registry Number</th>
                            <th class="text-right p-2 bg-gray-200">Amount</th>
                        </tr>
                    </thead>
                    <tbody>
                        {#if shareBalancesEntries.length > 0}
                            {#each shareBalancesEntries as [address, ticket]}
                                <tr class="border-t">
                                    <td class="font-mono p-2">{ticket.ticketer}</td>
                                    <td class="text-right p-2">{ticket.value}</td>
                                    <td class="text-right p-2">{ticket.amount}</td>
                                </tr>
                            {/each}
                        {:else}
                            <tr>
                                <td colspan="3" class="text-center p-2">No share balances found</td>
                            </tr>
                        {/if}
                    </tbody>
                </table>
            </div>
        </div>
        <!-- Admin Functions -->
        {#if storageData?.admin_address }
            <div class="mb-8 p-4 bg-blue-50 rounded-lg">
                <h2 class="text-2xl font-bold mb-4">Admin Functions</h2>
                
                <!-- Add Share Owner Form -->
                <form on:submit|preventDefault={addShareOwner} class="mb-4">
                    <h3 class="text-xl font-semibold mb-2">Add Share Owner</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <input 
                            type="number" 
                            bind:value={adminForms.addShareOwner.amount}
                            placeholder="Amount"
                            class="p-2 border rounded"
                        />
                        <input 
                            type="text" 
                            bind:value={adminForms.addShareOwner.ownerAddress}
                            placeholder="Owner Address"
                            class="p-2 border rounded"
                        />
                    </div>
                    <button 
                        type="submit"
                        class="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    >
                        Add Owner
                    </button>
                </form>

                <!-- Change Max Shares Form -->
                <form on:submit|preventDefault={changeMaxShares} class="mb-4">
                    <h3 class="text-xl font-semibold mb-2">Change Max Shares</h3>
                    <input 
                        type="number" 
                        bind:value={adminForms.changeMaxShares.newMax}
                        placeholder="New Maximum Shares"
                        class="p-2 border rounded"
                    />
                    <button 
                        type="submit"
                        class="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    >
                        Update Max Shares
                    </button>
                </form>

                <!-- Issue Shares Form -->
                <form on:submit|preventDefault={issueShares}>
                    <h3 class="text-xl font-semibold mb-2">Issue Shares</h3>
                    <input 
                        type="number" 
                        bind:value={adminForms.issueShares.amount}
                        placeholder="Amount to Issue"
                        class="p-2 border rounded"
                    />
                    <button 
                        type="submit"
                        class="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    >
                        Issue Shares
                    </button>
                </form>
            </div>
        {/if}

        <!-- User Functions -->
        <div class="mb-8 p-4 bg-green-50 rounded-lg">
            <h2 class="text-2xl font-bold mb-4">User Functions</h2>
            
            <!-- Transfer Shares Form -->
            <form on:submit|preventDefault={transferShares} class="mb-4">
                <h3 class="text-xl font-semibold mb-2">Transfer Shares</h3>
                <div class="grid grid-cols-3 gap-4">
                    <input 
                        type="number" 
                        bind:value={userForms.transferShares.amount}
                        placeholder="Amount"
                        class="p-2 border rounded"
                    />
                    <input 
                        type="text" 
                        bind:value={userForms.transferShares.destination}
                        placeholder="Destination Address"
                        class="p-2 border rounded"
                    />
                    <input 
                        type="text" 
                        bind:value={userForms.transferShares.share}
                        placeholder="Share Address"
                        class="p-2 border rounded"
                    />
                </div>
                <button 
                    type="submit"
                    class="mt-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                >
                    Transfer Shares
                </button>
            </form>

            <!-- Claim Shares Form -->
            <form on:submit|preventDefault={claimShares}>
                <h3 class="text-xl font-semibold mb-2">Claim Shares</h3>
                <input 
                    type="text" 
                    bind:value={userForms.claimShares.address}
                    placeholder="Address"
                    class="p-2 border rounded"
                />
                <button 
                    type="submit"
                    class="mt-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                >
                    Claim Shares
                </button>
            </form>
        </div>
    {/if}
</div>

<style>
    
</style>
</file>

<file path="src/lib/ContractOps.svelte">
<script lang="ts">
    import { contractState, contractInstance } from './stores/contractStore.svelte';
    import { tzktStorageData } from './stores/tzktStorage.svelte';
    import { beaconState, walletStore } from './stores/beaconStore.svelte';
    import { get } from "svelte/store";
    import { Tezos, wallet, resetProvider } from './config/beaconConfig';
    import { loadContractTzkt } from './utils/contractLoader';


    const isAdmin = $derived(
        beaconState.address !== null && 
        tzktStorageData.admin_address !== null && 
        beaconState.address === tzktStorageData.admin_address
    );
 

    // Form states
    let adminForms = $state({
        addShareOwner: { 
            amount: '' as string | number,
            ownerAddress: '' 
        },
        changeMaxShares: { newMax: null as number | null },
        issueShares: { amount: null as number | null },
        addCompanyData: {
            allSharesIssued: false,
            issuedShares: null as number | null,
            maxShares: null as number | null,
            registryNumber: ''
        },
        changeAdmin: { newAdminAddress: '' },
        removeShareOwner: { ownerAddress: '' }
    });
    
    let userForms = $state({
        transferShares: { amount: null as number | null, destination: '', share: '' },
        claimShares: { address: '' },
        claimSharesDirect: { destination_address: '' }
    });

    // Add loading states
    let loadingStates = $state({
        addShareOwner: false,
        changeMaxShares: false,
        issueShares: false,
        addCompanyData: false,
        changeAdmin: false,
        removeShareOwner: false,
        transferShares: false,
        claimShares: false,
        claimSharesDirect: false
    });

    // Add error states
    let errorStates = $state({
        addShareOwner: null as string | null,
        changeMaxShares: null as string | null,
        issueShares: null as string | null,
        addCompanyData: null as string | null,
        changeAdmin: null as string | null,
        removeShareOwner: null as string | null,
        transferShares: null as string | null,
        claimShares: null as string | null,
        claimSharesDirect: null as string | null
    });

    async function connectContract() {
        try {
            // First ensure provider is properly configured
            await resetProvider();
            
            console.log("Wallet ready for contract:", wallet?.getPKH());
        
            if (!$contractState.contractAddress) {
                throw new Error("Contract address not set");
            }
            if (!beaconState.isConnected) {
                throw new Error("Wallet not connected");
            }

            // Get the contract instance
            const contract = await Tezos.wallet.at($contractState.contractAddress);
            console.log("Contract connected successfully", contract);
            contractInstance.set(contract);

            
        } catch (error) {
            console.error("Failed to load contract:", error);
            throw error;
        }
    }



    // Admin Functions
    async function handleAddShareOwner(event: Event) {
        event.preventDefault();
        loadingStates.addShareOwner = true;
        errorStates.addShareOwner = null;
        
        try {
            // Validate amount is a number
            const amount = Number(adminForms.addShareOwner.amount);
            if (isNaN(amount)) {
                throw new Error("Amount must be a valid number");
            }

            await resetProvider();
  
            const operation = await $contractInstance.methodsObject.add_share_owner({
                amount: amount,
                owner_address: adminForms.addShareOwner.ownerAddress
            }).send();

            await operation.confirmation(2);
            console.log("Share owner added successfully");
            
            // Reset form
            adminForms.addShareOwner = { amount: '', ownerAddress: '' };
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();
            
        } catch (error) {
            console.error("Failed to add share owner:", error);
            errorStates.addShareOwner = error instanceof Error ? error.message : "Failed to add share owner";
        } finally {
            loadingStates.addShareOwner = false;
        }
    }

    async function handleChangeMaxShares(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methods.change_max_shares(
                adminForms.changeMaxShares.newMax
            ).send();

            await operation.confirmation(2)
            .then((op: any) => {
                console.log("Max shares updated successfully", op);
            });

            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();

            adminForms.changeMaxShares.newMax = null;
            
        } catch (error) {
            console.error("Failed to change max shares:", error);
            throw error;
        }
    }

    async function handleIssueShares(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methods.issue_shares_unclaimed2(
                adminForms.issueShares.amount
            ).send();

            await operation.confirmation(2)
            .then((op: any) => {
                console.log("Shares issued successfully", op);
            });

            adminForms.issueShares.amount = null;
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();
        } catch (error) {
            console.error("Failed to issue shares:", error);
            throw error;
        }
    }

    // User Functions
    async function handleTransferShares(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methods.transfer_shares(
                userForms.transferShares.amount,
                userForms.transferShares.destination,
                userForms.transferShares.share
            ).send();

            await operation.confirmation(2)
            .then((op: any) => {
                console.log("Shares transferred successfully", op);
            });

            userForms.transferShares = { amount: null, destination: '', share: '' };
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();
        } catch (error) {
            console.error("Failed to transfer shares:", error);
            throw error;
        }
    }

    async function handleClaimShares(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();            

            const operation = await $contractInstance.methods.claim_shares(
                userForms.claimShares.address
            ).send();

            await operation.confirmation(2)
            .then((op: any) => {
                console.log("Shares claimed successfully", op);
            });

            userForms.claimShares.address = '';
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();
        } catch (error) {
            console.error("Failed to claim shares:", error);
            throw error;
        }
    }

    // New User Function: Direct Claim Shares
    async function handleClaimSharesDirect(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methods.claim_shares_direct({
                destination_address: userForms.claimSharesDirect.destination_address
            }).send();

            await operation.confirmation(2).then((op: any) => {
                console.log("Direct claim of shares successful", op);
            });

            // Reset the direct claim form
            userForms.claimSharesDirect.destination_address = '';
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();
        } catch (error) {
            console.error("Failed to claim shares directly:", error);
            throw error;
        }
    }

    // New admin functions
    async function handleAddCompanyData(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methodsObject.add_company_data({
                all_shares_issued: adminForms.addCompanyData.allSharesIssued,
                issued_shares: adminForms.addCompanyData.issuedShares,
                max_shares: adminForms.addCompanyData.maxShares,
                registry_number: adminForms.addCompanyData.registryNumber
            }).send();

            await operation.confirmation(2);
            console.log("Company data added successfully", operation);
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();

            adminForms.addCompanyData = {
                allSharesIssued: false,
                issuedShares: null,
                maxShares: null,
                registryNumber: ''
            };
        } catch (error) {
            console.error("Failed to add company data:", error);
            throw error;
        }
    }

    async function handleChangeAdmin(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methods.change_admin(
                adminForms.changeAdmin.newAdminAddress
            ).send();

            await operation.confirmation(2);
            console.log("Admin changed successfully", operation);
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();

            adminForms.changeAdmin.newAdminAddress = '';
        } catch (error) {
            console.error("Failed to change admin:", error);
            throw error;
        }
    }

    async function handleRemoveShareOwner(event: Event) {
        event.preventDefault();
        try {
            await resetProvider();

            const operation = await $contractInstance.methods.remove_share_owner(
                adminForms.removeShareOwner.ownerAddress
            ).send();

            await operation.confirmation(2);
            console.log("Share owner removed successfully", operation);
            
            await new Promise(resolve => setTimeout(resolve, 2500));
            await loadContractTzkt();

            adminForms.removeShareOwner.ownerAddress = '';
        } catch (error) {
            console.error("Failed to remove share owner:", error);
            throw error;
        }
    }

    // Debug effect to help track state changes
    $effect(() => {
        console.log('State Debug:', {
            beaconAddress: beaconState.address,
            adminAddress: tzktStorageData.admin_address,
            isAdmin
        });
    });
</script>

<div>
    <!-- Always visible Connect to Contract section -->
    <div class="p-4">
        <button 
            onclick={connectContract}
            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
            { $contractInstance ? "Reconnect to Contract" : "Connect to Contract" }
        </button>
        {#if $contractState.contractAddress}
            <div class="mt-2 text-sm">
                Contract Address: {$contractState.contractAddress}
            </div>
        {/if}
    </div>

    <!-- Provide user feedback if wallet is not connected -->
    {#if !beaconState.isConnected}
        <div class="p-4 text-gray-600">
            Please connect your wallet first to interact with the contract.
        </div>
    {/if}

    <!-- Display operations forms if a contract is connected and wallet is connected -->
    {#if $contractInstance && beaconState.isConnected}
        <div class="p-4 space-y-6">
            {#if isAdmin}
                <div class="bg-blue-50 p-4 rounded-lg">
                    <h2 class="text-2xl font-bold mb-4">Admin Functions</h2>
                    
                    <!-- Add Share Owner Form -->
                    <form class="mb-4 space-y-4" onsubmit={handleAddShareOwner}>
                        <h3 class="text-xl font-semibold">Add Share Owner</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <input 
                                type="number" 
                                bind:value={adminForms.addShareOwner.amount}
                                placeholder="Amount"
                                class="p-2 border rounded"
                                disabled={loadingStates.addShareOwner}
                            />
                            <input 
                                type="text" 
                                bind:value={adminForms.addShareOwner.ownerAddress}
                                placeholder="Owner Address"
                                class="p-2 border rounded"
                                disabled={loadingStates.addShareOwner}
                            />
                        </div>
                        {#if errorStates.addShareOwner}
                            <div class="text-red-500 text-sm">{errorStates.addShareOwner}</div>
                        {/if}
                        <button 
                            type="submit"
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-blue-300"
                            disabled={loadingStates.addShareOwner}
                        >
                            {loadingStates.addShareOwner ? 'Adding...' : 'Add Owner'}
                        </button>
                    </form>

                    <!-- Change Max Shares Form -->
                    <form class="mb-4 space-y-4" onsubmit={handleChangeMaxShares}>
                        <h3 class="text-xl font-semibold">Change Max Shares</h3>
                        <input 
                            type="number" 
                            bind:value={adminForms.changeMaxShares.newMax}
                            placeholder="New Maximum Shares"
                            class="p-2 border rounded"
                        />
                        <button 
                            type="submit"
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                        >
                            Update Max Shares
                        </button>
                    </form>

                    <!-- Issue Shares Form -->
                    <form class="space-y-4" onsubmit={handleIssueShares}>
                        <h3 class="text-xl font-semibold">Issue Shares</h3>
                        <input 
                            type="number" 
                            bind:value={adminForms.issueShares.amount}
                            placeholder="Amount to Issue"
                            class="p-2 border rounded"
                        />
                        <button 
                            type="submit"
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                        >
                            Issue Shares
                        </button>
                    </form>

                    <!-- Add Company Data Form -->
                    <form class="mb-4 space-y-4" onsubmit={handleAddCompanyData}>
                        <h3 class="text-xl font-semibold">Add Company Data</h3>
                        <input 
                            type="text" 
                            bind:value={adminForms.addCompanyData.issuedShares}
                            placeholder="Issued Shares"
                            class="p-2 border rounded"
                        />
                        <input 
                            type="text" 
                            bind:value={adminForms.addCompanyData.maxShares}
                            placeholder="Max Shares"
                            class="p-2 border rounded"
                        />
                        <input 
                            type="text" 
                            bind:value={adminForms.addCompanyData.registryNumber}
                            placeholder="Registry Number"
                            class="p-2 border rounded"
                        />
                        <button 
                            type="submit"
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                        >
                            Add Company Data
                        </button>
                    </form>

                    <!-- Change Admin Form -->
                    <form class="mb-4 space-y-4" onsubmit={handleChangeAdmin}>
                        <h3 class="text-xl font-semibold">Change Admin</h3>
                        <input 
                            type="text" 
                            bind:value={adminForms.changeAdmin.newAdminAddress}
                            placeholder="New Admin Address"
                            class="p-2 border rounded"
                        />
                        <button 
                            type="submit"
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                        >
                            Change Admin
                        </button>
                    </form>

                    <!-- Remove Share Owner Form -->
                    <form class="space-y-4" onsubmit={handleRemoveShareOwner}>
                        <h3 class="text-xl font-semibold">Remove Share Owner</h3>
                        <input 
                            type="text" 
                            bind:value={adminForms.removeShareOwner.ownerAddress}
                            placeholder="Owner Address"
                            class="p-2 border rounded"
                        />
                        <button 
                            type="submit"
                            class="mt-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                        >
                            Remove Share Owner
                        </button>
                    </form>
                </div>
            {/if}

            <div class="bg-green-50 p-4 rounded-lg">
                <h2 class="text-2xl font-bold mb-4">User Functions</h2>
                
                <!-- Transfer Shares Form -->
                <form class="mb-4 space-y-4" onsubmit={handleTransferShares}>
                    <h3 class="text-xl font-semibold">Transfer Shares</h3>
                    <div class="grid grid-cols-3 gap-4">
                        <input 
                            type="number" 
                            bind:value={userForms.transferShares.amount}
                            placeholder="Amount"
                            class="p-2 border rounded"
                        />
                        <input 
                            type="text" 
                            bind:value={userForms.transferShares.destination}
                            placeholder="Destination Address"
                            class="p-2 border rounded"
                        />
                        <input 
                            type="text" 
                            bind:value={userForms.transferShares.share}
                            placeholder="Share Address"
                            class="p-2 border rounded"
                        />
                    </div>
                    <button 
                        type="submit"
                        class="mt-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                    >
                        Transfer Shares
                    </button>
                </form>

                <!-- Claim Shares Form -->
                <form class="space-y-4" onsubmit={handleClaimShares}>
                    <h3 class="text-xl font-semibold">Claim Shares</h3>
                    <input 
                        type="text" 
                        bind:value={userForms.claimShares.address}
                        placeholder="Address"
                        class="p-2 border rounded"
                    />
                    <button 
                        type="submit"
                        class="mt-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                    >
                        Claim Shares
                    </button>
                </form>

                <!-- Direct Claim Shares Form -->
                <form class="space-y-4" onsubmit={handleClaimSharesDirect}>
                    <h3 class="text-xl font-semibold">Direct Claim Shares</h3>
                    <input 
                        type="text" 
                        bind:value={userForms.claimSharesDirect.destination_address}
                        placeholder="Destination Address"
                        class="p-2 border rounded"
                    />
                    <button 
                        type="submit"
                        class="mt-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                    >
                        Direct Claim Shares
                    </button>
                </form>
            </div>
        </div>
    {/if}
</div>
</file>

<file path="src/lib/WalletConnectorBeacon.svelte">
<script lang="ts">
    import { onMount, onDestroy } from 'svelte';
    import { get } from 'svelte/store';
    import { BeaconEvent, SigningType } from '@airgap/beacon-sdk';
    import { beaconState, walletStore } from './stores/beaconStore.svelte';
    import { Tezos, wallet } from './config/beaconConfig';

    export const tezSym: string = 'ꜩ';

    

    //export const beaconDAppClient = getBeaconDAppClient();

    onMount(async () => {
        // Check for existing connection first, don't prompt if already connected
        if (await checkExistingConnection()) {
            return;
        } else {
            beaconState.isConnected = false;
        }
    });

    onDestroy(() => {
        try {
            disconnectWallet();
        } catch (error) {
            console.error("Failed to disconnect wallet:", error);
        }
    });


    export async function connectWallet() {
        beaconState.error = null;

        if (beaconState.isConnected) {
            console.log("Already connected");
            return;
        }

        Tezos.setWalletProvider(wallet);

        wallet.client.subscribeToEvent(BeaconEvent.ACTIVE_ACCOUNT_SET, (account) => {
            // An active account has been set
            //console.log(`${BeaconEvent.ACTIVE_ACCOUNT_SET} triggered: `, account);
            
            if (!account) {
                return;
            }
            
            beaconState.address = account.address;
            beaconState.isConnected = true;
        });
        try {
            console.log("Connecting to wallet...");
            const activeAccount = wallet
            
            console.log("Requesting permissions...");
            const permissions = await activeAccount.client.requestPermissions();
            console.log("Got permissions for:", permissions.address);
            try {
                await activeAccount.client.requestSignPayload({
                    signingType: SigningType.RAW,
                    //payload: "05010000004254657a6f73205369676e6564204d6573736167653a207465737455726c20323032332d30322d30385431303a33363a31382e3435345a2048656c6c6f20576f726c64",
                    payload: "This is SPARTA",

                })
                .then((response) => {
                    console.log("Signature:", response.signature);
                });
                // Setting beaconState values
                beaconState.isConnected = true;
                beaconState.address = await activeAccount.getPKH();
                beaconState.wbalance = await getWalletBalance(beaconState.address);
                beaconState.isConnected = true;
                
                // Saving the Wallet instance to the store
                walletStore.set(activeAccount);
                
                console.log("Connected to wallet:", beaconState.address);

            } catch (err: any) {
                // The request was rejected
                disconnectWallet();
            }

        } catch (error) {
            console.error("Connection error:", error);
            disconnectWallet();
            beaconState.error = error instanceof Error ? error.message : "Failed to connect wallet";
        }

        
        
    }

    export async function disconnectWallet() {
        console.log("Disconnecting wallet...");
        Tezos.setWalletProvider(wallet);
        try {
            await wallet.client.clearActiveAccount();
            await wallet.disconnect();

            walletStore.set(null);
            
            console.log("Wallet disconnected");
            beaconState.address = null;
            beaconState.isConnected = false;
            beaconState.error = null;
            
            
        } catch (error) {
            console.error("Disconnection error:", error);
            beaconState.error = error instanceof Error ? error.message : "Failed to disconnect wallet";
        }
    }

    export async function checkExistingConnection() {
        try {
            console.log("Checking existing connection...");
            const activeAccount = await wallet.client.getActiveAccount();
            if (activeAccount) {
                beaconState.address = activeAccount.address;
                beaconState.isConnected = true;
                console.log("Found existing connection:", activeAccount.address);
                beaconState.wbalance = await getWalletBalance(beaconState.address);

                return true;
            } else {
                console.log("No existing connection found during onMount");
                return false;
            }
        } catch (error) {
            console.error("Error checking existing connection:", error);
            beaconState.error = error instanceof Error ? error.message : "Failed to check wallet connection";
        }
        return false;
    }

    // get balance
    export async function getWalletBalance(address: string) {
        const balance = await Tezos.tz.getBalance(address);
        beaconState.wbalance =  balance.toNumber() / 1000000;
        console.log("Balance:", balance.toNumber() / 1000000);
        return balance.toNumber() / 1000000;
    }

</script>

<div class="container mx-auto p-4 bg-gray-100 rounded-md">
    <h2 class="text-2xl font-bold mb-4">Wallet Information</h2>
    {#if beaconState.error}
        <div class="p-4 mb-4 bg-red-100 text-red-700 rounded-lg">
            {beaconState.error}
        </div>
    {/if}

    {#if beaconState.isConnected}
        <div class="grid grid-cols-5 gap-4">
            <div class="col-span-4">
                <span class="font-semibold">Address:</span>
                <span class="font-mono">{beaconState.address}</span> 
            </div>
            <div class="flex justify-end">
                <span class="font-semibold">Balance:</span>
                <span>{beaconState.wbalance} {tezSym}</span>
            </div>
            
            <button 
                class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                onclick={disconnectWallet}
            >
                Disconnect
            </button>
        </div>
    {:else}
        <button 
            class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
            onclick={connectWallet}
        >
            Connect Wallet
        </button>
    {/if}
</div>
</file>

</files>
