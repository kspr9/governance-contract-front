The Mental Model: When to Use What
Now that you've seen the pieces, let me help you understand the decision-making framework that determines where each piece of styling should live. Think of this like organizing a workshop: you want your most frequently used tools within easy reach, your specialized tools organized by category, and your project-specific materials kept with their respective projects.
Global CSS (app.css) is for your foundational tools—the things that every component might need. This includes your design tokens (those CSS custom properties), reset styles, and utility classes that you'll use everywhere. The rule of thumb is: if three or more components would benefit from it, and it represents a core design decision, it belongs in global CSS.
Your design tokens are particularly important here because they act as the single source of truth for your design decisions. When you change --color-primary-500 in one place, it updates everywhere that color is used. This eliminates the maintenance nightmare of hunting down every instance of a specific blue color across your codebase.
Component-level CSS using the CVA (Class Variance Authority) pattern is for your specialized tools—components that have multiple variations but follow consistent patterns. This is where you solve the Tailwind verbosity problem. Instead of repeating bg-blue-600 text-white hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 px-4 py-2 rounded-md everywhere you want a primary button, you create the abstraction once and reuse it semantically.
The key insight here is that you're not fighting Tailwind—you're using it as intended. Tailwind works best when you compose its utilities into meaningful abstractions rather than using it like inline styles.
Component-specific styles (in the <style> block) are for your project-specific materials—truly unique styling that doesn't make sense to abstract or reuse. This might be complex animations, component-specific pseudo-elements, or styling that's so specific to one use case that making it reusable would actually make it harder to understand.

Solving the Verbosity Problem
Your concern about Tailwind being verbose stems from a common misconception about how to use utility-first CSS effectively. The pattern you're worried about—copying the same long string of classes everywhere—is actually an anti-pattern. It's like using a screwdriver as a hammer; it might work, but you're not using the tool correctly.
The solution is to think in terms of semantic abstractions. Instead of thinking "I need these specific Tailwind classes," think "I need a primary button" or "I need a content card." Then you build those abstractions once using the CVA pattern I showed you, and you get all the benefits of Tailwind's utility system without the maintenance overhead.
This approach gives you several advantages that aren't immediately obvious. First, when you need to change how all primary buttons look, you modify one place rather than hunting through dozens of files. Second, when you're building a new feature, you think in terms of your design system's vocabulary, which makes your code more consistent and your development faster. Third, when a designer asks you to adjust the spacing on all cards, you change a few lines in your Card component rather than searching and replacing across your entire codebase.

Building Maintainable Patterns
As your application grows, you'll discover patterns that appear frequently but don't quite fit into your existing components. This is normal and healthy—it means your design system is evolving with your product's needs. The key is to recognize these patterns early and extract them into reusable abstractions before they become maintenance burdens.
For example, you might notice that you frequently need a "section" pattern—a container with a specific background, padding, and optional divider. Rather than repeating these styles everywhere, you'd create a Section component that encapsulates this pattern. The rule of thumb is the "rule of three": if you find yourself copying similar styling three times, it's probably worth extracting into a component.
You also want to think about progressive enhancement in your design system. Start with the simplest, most common patterns and build up complexity as you need it. Your Button component might start with just primary and secondary variants, then grow to include sizes, then add special states like loading or disabled. This organic growth is much more sustainable than trying to anticipate every possible need upfront.

Avoiding Common Pitfalls
The biggest mistake I see developers make is trying to make everything configurable from the start. They'll create a Button component with twenty different props for every possible styling option. This actually makes the component harder to use and maintain than just using Tailwind classes directly.
Instead, start with the variations you actually need, and add new ones only when you have a real use case. Your design system should enable your team to move fast, not force them to make dozens of decisions for every button they want to add.
Another common pitfall is mixing levels of abstraction. You'll see code where someone uses a Card component but then adds Tailwind classes to override its styling. This breaks the abstraction and makes the code harder to understand. If you find yourself frequently overriding a component's styling, that's a signal that the component's API needs to be improved, not that you should start mixing approaches.
The mental model that helps here is to think of your design system as a language. You want your components to be like words that have clear meanings, and your page compositions to be like sentences that use those words correctly. When you start mixing levels of abstraction, it's like switching languages mid-sentence—it works, but it's confusing for everyone who reads it later.
This approach scales beautifully as your team and application grow. New developers can learn your design system's vocabulary and immediately be productive. Designers can speak in terms of the components you've built rather than having to specify every detail. And when you need to make large-scale changes, you have the leverage points to make them efficiently.
The key to making this work long-term is treating your design system as a product that serves your team. Just like any product, it needs to evolve based on user feedback—in this case, feedback from your fellow developers about what's hard to build or maintain. Regular design system reviews where you identify pain points and opportunities for improvement will keep your system healthy and useful as your application grows.